/*
 * Open Payments
 * The Open Payments API is a simple REST API with 4 resource types: **wallet address**, **quote**, **incoming payment** and **outgoing payment**.  The *service endpoint* for the API is always the URL of the wallet address resource and all other resources are sub-resources of the wallet address.  An incoming payment defines meta data that is automatically attached to payments made into the wallet address under that incoming payment. This facilitates automation of processes like reconciliation of payment into the wallet address with external systems.  An outgoing payment is an instruction to make a payment out of the wallet address.  A quote is a commitment from the Account Servicing Entity to deliver a particular amount to a receiver when sending a particular amount from the wallet address. It is only valid for a limited time.  All resource and collection resource representations use JSON and the media-type `application/json`.    The `wallet address` resource has three collections of sub-resources: 1. `/incoming-payments` contains the **incoming payment** sub-resources   2. `/outgoing-payments` contains the **outgoing payment** sub-resources   3. `/quotes` contains the **quote** sub-resources  Access to resources and permission to execute the methods exposed by the API is determined by the grants given to the client represented by an access token used in API requests.
 *
 * The version of the OpenAPI document: 1.4
 * Contact: tech@interledger.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.fliqa.interledger.client.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.fliqa.interledger.client.model.Amount;
import io.fliqa.interledger.client.model.CreateQuoteRequestOneOf;
import io.fliqa.interledger.client.model.CreateQuoteRequestOneOf1;
import io.fliqa.interledger.client.model.CreateQuoteRequestOneOf2;
import io.fliqa.interledger.client.model.PaymentMethod;
import java.net.URI;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import com.fasterxml.jackson.core.type.TypeReference;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import io.fliqa.interledger.JSON;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.11.0")
@JsonDeserialize(using = CreateQuoteRequest.CreateQuoteRequestDeserializer.class)
@JsonSerialize(using = CreateQuoteRequest.CreateQuoteRequestSerializer.class)
public class CreateQuoteRequest extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(CreateQuoteRequest.class.getName());

    public static class CreateQuoteRequestSerializer extends StdSerializer<CreateQuoteRequest> {
        public CreateQuoteRequestSerializer(Class<CreateQuoteRequest> t) {
            super(t);
        }

        public CreateQuoteRequestSerializer() {
            this(null);
        }

        @Override
        public void serialize(CreateQuoteRequest value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
            jgen.writeObject(value.getActualInstance());
        }
    }

    public static class CreateQuoteRequestDeserializer extends StdDeserializer<CreateQuoteRequest> {
        public CreateQuoteRequestDeserializer() {
            this(CreateQuoteRequest.class);
        }

        public CreateQuoteRequestDeserializer(Class<?> vc) {
            super(vc);
        }

        @Override
        public CreateQuoteRequest deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
            JsonNode tree = jp.readValueAsTree();
            Object deserialized = null;
            boolean typeCoercion = ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS);
            int match = 0;
            JsonToken token = tree.traverse(jp.getCodec()).nextToken();
            // deserialize CreateQuoteRequestOneOf
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (CreateQuoteRequestOneOf.class.equals(Integer.class) || CreateQuoteRequestOneOf.class.equals(Long.class) || CreateQuoteRequestOneOf.class.equals(Float.class) || CreateQuoteRequestOneOf.class.equals(Double.class) || CreateQuoteRequestOneOf.class.equals(Boolean.class) || CreateQuoteRequestOneOf.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((CreateQuoteRequestOneOf.class.equals(Integer.class) || CreateQuoteRequestOneOf.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((CreateQuoteRequestOneOf.class.equals(Float.class) || CreateQuoteRequestOneOf.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (CreateQuoteRequestOneOf.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (CreateQuoteRequestOneOf.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(CreateQuoteRequestOneOf.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'CreateQuoteRequestOneOf'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'CreateQuoteRequestOneOf'", e);
            }

            // deserialize CreateQuoteRequestOneOf1
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (CreateQuoteRequestOneOf1.class.equals(Integer.class) || CreateQuoteRequestOneOf1.class.equals(Long.class) || CreateQuoteRequestOneOf1.class.equals(Float.class) || CreateQuoteRequestOneOf1.class.equals(Double.class) || CreateQuoteRequestOneOf1.class.equals(Boolean.class) || CreateQuoteRequestOneOf1.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((CreateQuoteRequestOneOf1.class.equals(Integer.class) || CreateQuoteRequestOneOf1.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((CreateQuoteRequestOneOf1.class.equals(Float.class) || CreateQuoteRequestOneOf1.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (CreateQuoteRequestOneOf1.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (CreateQuoteRequestOneOf1.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(CreateQuoteRequestOneOf1.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'CreateQuoteRequestOneOf1'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'CreateQuoteRequestOneOf1'", e);
            }

            // deserialize CreateQuoteRequestOneOf2
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (CreateQuoteRequestOneOf2.class.equals(Integer.class) || CreateQuoteRequestOneOf2.class.equals(Long.class) || CreateQuoteRequestOneOf2.class.equals(Float.class) || CreateQuoteRequestOneOf2.class.equals(Double.class) || CreateQuoteRequestOneOf2.class.equals(Boolean.class) || CreateQuoteRequestOneOf2.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((CreateQuoteRequestOneOf2.class.equals(Integer.class) || CreateQuoteRequestOneOf2.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((CreateQuoteRequestOneOf2.class.equals(Float.class) || CreateQuoteRequestOneOf2.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (CreateQuoteRequestOneOf2.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (CreateQuoteRequestOneOf2.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(CreateQuoteRequestOneOf2.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'CreateQuoteRequestOneOf2'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'CreateQuoteRequestOneOf2'", e);
            }

            if (match == 1) {
                CreateQuoteRequest ret = new CreateQuoteRequest();
                ret.setActualInstance(deserialized);
                return ret;
            }
            throw new IOException(String.format("Failed deserialization for CreateQuoteRequest: %d classes match result, expected 1", match));
        }

        /**
         * Handle deserialization of the 'null' value.
         */
        @Override
        public CreateQuoteRequest getNullValue(DeserializationContext ctxt) throws JsonMappingException {
            throw new JsonMappingException(ctxt.getParser(), "CreateQuoteRequest cannot be null");
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, Class<?>> schemas = new HashMap<>();

    public CreateQuoteRequest() {
        super("oneOf", Boolean.FALSE);
    }

    public CreateQuoteRequest(CreateQuoteRequestOneOf o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CreateQuoteRequest(CreateQuoteRequestOneOf1 o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CreateQuoteRequest(CreateQuoteRequestOneOf2 o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("CreateQuoteRequestOneOf", CreateQuoteRequestOneOf.class);
        schemas.put("CreateQuoteRequestOneOf1", CreateQuoteRequestOneOf1.class);
        schemas.put("CreateQuoteRequestOneOf2", CreateQuoteRequestOneOf2.class);
        JSON.registerDescendants(CreateQuoteRequest.class, Collections.unmodifiableMap(schemas));
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return CreateQuoteRequest.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * CreateQuoteRequestOneOf, CreateQuoteRequestOneOf1, CreateQuoteRequestOneOf2
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (JSON.isInstanceOf(CreateQuoteRequestOneOf.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(CreateQuoteRequestOneOf1.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(CreateQuoteRequestOneOf2.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be CreateQuoteRequestOneOf, CreateQuoteRequestOneOf1, CreateQuoteRequestOneOf2");
    }

    /**
     * Get the actual instance, which can be the following:
     * CreateQuoteRequestOneOf, CreateQuoteRequestOneOf1, CreateQuoteRequestOneOf2
     *
     * @return The actual instance (CreateQuoteRequestOneOf, CreateQuoteRequestOneOf1, CreateQuoteRequestOneOf2)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `CreateQuoteRequestOneOf`. If the actual instance is not `CreateQuoteRequestOneOf`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CreateQuoteRequestOneOf`
     * @throws ClassCastException if the instance is not `CreateQuoteRequestOneOf`
     */
    public CreateQuoteRequestOneOf getCreateQuoteRequestOneOf() throws ClassCastException {
        return (CreateQuoteRequestOneOf)super.getActualInstance();
    }

    /**
     * Get the actual instance of `CreateQuoteRequestOneOf1`. If the actual instance is not `CreateQuoteRequestOneOf1`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CreateQuoteRequestOneOf1`
     * @throws ClassCastException if the instance is not `CreateQuoteRequestOneOf1`
     */
    public CreateQuoteRequestOneOf1 getCreateQuoteRequestOneOf1() throws ClassCastException {
        return (CreateQuoteRequestOneOf1)super.getActualInstance();
    }

    /**
     * Get the actual instance of `CreateQuoteRequestOneOf2`. If the actual instance is not `CreateQuoteRequestOneOf2`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CreateQuoteRequestOneOf2`
     * @throws ClassCastException if the instance is not `CreateQuoteRequestOneOf2`
     */
    public CreateQuoteRequestOneOf2 getCreateQuoteRequestOneOf2() throws ClassCastException {
        return (CreateQuoteRequestOneOf2)super.getActualInstance();
    }



  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    if (getActualInstance() instanceof CreateQuoteRequestOneOf) {
        if (getActualInstance() != null) {
          joiner.add(((CreateQuoteRequestOneOf)getActualInstance()).toUrlQueryString(prefix + "one_of_0" + suffix));
        }
        return joiner.toString();
    }
    if (getActualInstance() instanceof CreateQuoteRequestOneOf1) {
        if (getActualInstance() != null) {
          joiner.add(((CreateQuoteRequestOneOf1)getActualInstance()).toUrlQueryString(prefix + "one_of_1" + suffix));
        }
        return joiner.toString();
    }
    if (getActualInstance() instanceof CreateQuoteRequestOneOf2) {
        if (getActualInstance() != null) {
          joiner.add(((CreateQuoteRequestOneOf2)getActualInstance()).toUrlQueryString(prefix + "one_of_2" + suffix));
        }
        return joiner.toString();
    }
    return null;
  }

}

