/*
 * Open Payments
 * The Open Payments API is a simple REST API with 4 resource types: **wallet address**, **quote**, **incoming payment** and **outgoing payment**.  The *service endpoint* for the API is always the URL of the wallet address resource and all other resources are sub-resources of the wallet address.  An incoming payment defines meta data that is automatically attached to payments made into the wallet address under that incoming payment. This facilitates automation of processes like reconciliation of payment into the wallet address with external systems.  An outgoing payment is an instruction to make a payment out of the wallet address.  A quote is a commitment from the Account Servicing Entity to deliver a particular amount to a receiver when sending a particular amount from the wallet address. It is only valid for a limited time.  All resource and collection resource representations use JSON and the media-type `application/json`.    The `wallet address` resource has three collections of sub-resources: 1. `/incoming-payments` contains the **incoming payment** sub-resources   2. `/outgoing-payments` contains the **outgoing payment** sub-resources   3. `/quotes` contains the **quote** sub-resources  Access to resources and permission to execute the methods exposed by the API is determined by the grants given to the client represented by an access token used in API requests.
 *
 * The version of the OpenAPI document: 1.4
 * Contact: tech@interledger.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package io.fliqa.interledger.client;

import io.fliqa.interledger.ApiClient;
import io.fliqa.interledger.ApiException;
import io.fliqa.interledger.ApiResponse;
import io.fliqa.interledger.Pair;

import io.fliqa.interledger.client.model.CreateOutgoingPaymentRequest;
import io.fliqa.interledger.client.model.ListOutgoingPayments200Response;
import io.fliqa.interledger.client.model.OutgoingPayment;
import io.fliqa.interledger.client.model.OutgoingPaymentWithSpentAmounts;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.11.0")
public class OutgoingPaymentApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public OutgoingPaymentApi() {
    this(new ApiClient());
  }

  public OutgoingPaymentApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Create an Outgoing Payment
   * An **outgoing payment** is a sub-resource of a wallet address. It represents a payment from the wallet address.  Once created, it is already authorized and SHOULD be processed immediately. If payment fails, the Account Servicing Entity must mark the **outgoing payment** as &#x60;failed&#x60;.
   * @param signatureInput  (required)
   * @param signature The signature generated based on the Signature-Input, using the signing algorithm specified in the \&quot;alg\&quot; field of the JWK. (required)
   * @param createOutgoingPaymentRequest A subset of the outgoing payments schema is accepted as input to create a new outgoing payment.  The &#x60;debitAmount&#x60; must use the same &#x60;assetCode&#x60; and &#x60;assetScale&#x60; as the wallet address.  Either provide a &#x60;quoteId&#x60; to create an outgoing payment based on a quote or provide &#x60;incomingPayment&#x60; and &#x60;debitAmount&#x60; to create an outgoing payment directly from an incoming payment. (required)
   * @return OutgoingPaymentWithSpentAmounts
   * @throws ApiException if fails to make API call
   */
  public OutgoingPaymentWithSpentAmounts createOutgoingPayment(String signatureInput, String signature, CreateOutgoingPaymentRequest createOutgoingPaymentRequest) throws ApiException {
    ApiResponse<OutgoingPaymentWithSpentAmounts> localVarResponse = createOutgoingPaymentWithHttpInfo(signatureInput, signature, createOutgoingPaymentRequest);
    return localVarResponse.getData();
  }

  /**
   * Create an Outgoing Payment
   * An **outgoing payment** is a sub-resource of a wallet address. It represents a payment from the wallet address.  Once created, it is already authorized and SHOULD be processed immediately. If payment fails, the Account Servicing Entity must mark the **outgoing payment** as &#x60;failed&#x60;.
   * @param signatureInput  (required)
   * @param signature The signature generated based on the Signature-Input, using the signing algorithm specified in the \&quot;alg\&quot; field of the JWK. (required)
   * @param createOutgoingPaymentRequest A subset of the outgoing payments schema is accepted as input to create a new outgoing payment.  The &#x60;debitAmount&#x60; must use the same &#x60;assetCode&#x60; and &#x60;assetScale&#x60; as the wallet address.  Either provide a &#x60;quoteId&#x60; to create an outgoing payment based on a quote or provide &#x60;incomingPayment&#x60; and &#x60;debitAmount&#x60; to create an outgoing payment directly from an incoming payment. (required)
   * @return ApiResponse&lt;OutgoingPaymentWithSpentAmounts&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<OutgoingPaymentWithSpentAmounts> createOutgoingPaymentWithHttpInfo(String signatureInput, String signature, CreateOutgoingPaymentRequest createOutgoingPaymentRequest) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = createOutgoingPaymentRequestBuilder(signatureInput, signature, createOutgoingPaymentRequest);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("createOutgoingPayment", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<OutgoingPaymentWithSpentAmounts>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<OutgoingPaymentWithSpentAmounts>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<OutgoingPaymentWithSpentAmounts>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder createOutgoingPaymentRequestBuilder(String signatureInput, String signature, CreateOutgoingPaymentRequest createOutgoingPaymentRequest) throws ApiException {
    // verify the required parameter 'signatureInput' is set
    if (signatureInput == null) {
      throw new ApiException(400, "Missing the required parameter 'signatureInput' when calling createOutgoingPayment");
    }
    // verify the required parameter 'signature' is set
    if (signature == null) {
      throw new ApiException(400, "Missing the required parameter 'signature' when calling createOutgoingPayment");
    }
    // verify the required parameter 'createOutgoingPaymentRequest' is set
    if (createOutgoingPaymentRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'createOutgoingPaymentRequest' when calling createOutgoingPayment");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/outgoing-payments";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (signatureInput != null) {
      localVarRequestBuilder.header("Signature-Input", signatureInput.toString());
    }
    if (signature != null) {
      localVarRequestBuilder.header("Signature", signature.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(createOutgoingPaymentRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Get an Outgoing Payment
   * A client can fetch the latest state of an outgoing payment.
   * @param signatureInput  (required)
   * @param signature The signature generated based on the Signature-Input, using the signing algorithm specified in the \&quot;alg\&quot; field of the JWK. (required)
   * @param id Sub-resource identifier (required)
   * @return OutgoingPayment
   * @throws ApiException if fails to make API call
   */
  public OutgoingPayment getOutgoingPayment(String signatureInput, String signature, String id) throws ApiException {
    ApiResponse<OutgoingPayment> localVarResponse = getOutgoingPaymentWithHttpInfo(signatureInput, signature, id);
    return localVarResponse.getData();
  }

  /**
   * Get an Outgoing Payment
   * A client can fetch the latest state of an outgoing payment.
   * @param signatureInput  (required)
   * @param signature The signature generated based on the Signature-Input, using the signing algorithm specified in the \&quot;alg\&quot; field of the JWK. (required)
   * @param id Sub-resource identifier (required)
   * @return ApiResponse&lt;OutgoingPayment&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<OutgoingPayment> getOutgoingPaymentWithHttpInfo(String signatureInput, String signature, String id) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getOutgoingPaymentRequestBuilder(signatureInput, signature, id);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getOutgoingPayment", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<OutgoingPayment>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<OutgoingPayment>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<OutgoingPayment>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getOutgoingPaymentRequestBuilder(String signatureInput, String signature, String id) throws ApiException {
    // verify the required parameter 'signatureInput' is set
    if (signatureInput == null) {
      throw new ApiException(400, "Missing the required parameter 'signatureInput' when calling getOutgoingPayment");
    }
    // verify the required parameter 'signature' is set
    if (signature == null) {
      throw new ApiException(400, "Missing the required parameter 'signature' when calling getOutgoingPayment");
    }
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling getOutgoingPayment");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/outgoing-payments/{id}"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (signatureInput != null) {
      localVarRequestBuilder.header("Signature-Input", signatureInput.toString());
    }
    if (signature != null) {
      localVarRequestBuilder.header("Signature", signature.toString());
    }
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List Outgoing Payments
   * List all outgoing payments on the wallet address
   * @param walletAddress URL of a wallet address hosted by a Rafiki instance. (required)
   * @param signatureInput  (required)
   * @param signature The signature generated based on the Signature-Input, using the signing algorithm specified in the \&quot;alg\&quot; field of the JWK. (required)
   * @param cursor The cursor key to list from. (optional)
   * @param first The number of items to return after the cursor. (optional)
   * @param last The number of items to return before the cursor. (optional)
   * @return ListOutgoingPayments200Response
   * @throws ApiException if fails to make API call
   */
  public ListOutgoingPayments200Response listOutgoingPayments(String walletAddress, String signatureInput, String signature, String cursor, Integer first, Integer last) throws ApiException {
    ApiResponse<ListOutgoingPayments200Response> localVarResponse = listOutgoingPaymentsWithHttpInfo(walletAddress, signatureInput, signature, cursor, first, last);
    return localVarResponse.getData();
  }

  /**
   * List Outgoing Payments
   * List all outgoing payments on the wallet address
   * @param walletAddress URL of a wallet address hosted by a Rafiki instance. (required)
   * @param signatureInput  (required)
   * @param signature The signature generated based on the Signature-Input, using the signing algorithm specified in the \&quot;alg\&quot; field of the JWK. (required)
   * @param cursor The cursor key to list from. (optional)
   * @param first The number of items to return after the cursor. (optional)
   * @param last The number of items to return before the cursor. (optional)
   * @return ApiResponse&lt;ListOutgoingPayments200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListOutgoingPayments200Response> listOutgoingPaymentsWithHttpInfo(String walletAddress, String signatureInput, String signature, String cursor, Integer first, Integer last) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = listOutgoingPaymentsRequestBuilder(walletAddress, signatureInput, signature, cursor, first, last);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("listOutgoingPayments", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<ListOutgoingPayments200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<ListOutgoingPayments200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ListOutgoingPayments200Response>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder listOutgoingPaymentsRequestBuilder(String walletAddress, String signatureInput, String signature, String cursor, Integer first, Integer last) throws ApiException {
    // verify the required parameter 'walletAddress' is set
    if (walletAddress == null) {
      throw new ApiException(400, "Missing the required parameter 'walletAddress' when calling listOutgoingPayments");
    }
    // verify the required parameter 'signatureInput' is set
    if (signatureInput == null) {
      throw new ApiException(400, "Missing the required parameter 'signatureInput' when calling listOutgoingPayments");
    }
    // verify the required parameter 'signature' is set
    if (signature == null) {
      throw new ApiException(400, "Missing the required parameter 'signature' when calling listOutgoingPayments");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/outgoing-payments";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "wallet-address";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("wallet-address", walletAddress));
    localVarQueryParameterBaseName = "cursor";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("cursor", cursor));
    localVarQueryParameterBaseName = "first";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("first", first));
    localVarQueryParameterBaseName = "last";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("last", last));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    if (signatureInput != null) {
      localVarRequestBuilder.header("Signature-Input", signatureInput.toString());
    }
    if (signature != null) {
      localVarRequestBuilder.header("Signature", signature.toString());
    }
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

}
