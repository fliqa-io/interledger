/*
 * Open Payments
 * The Open Payments API is a simple REST API with 4 resource types: **wallet address**, **quote**, **incoming payment** and **outgoing payment**.  The *service endpoint* for the API is always the URL of the wallet address resource and all other resources are sub-resources of the wallet address.  An incoming payment defines meta data that is automatically attached to payments made into the wallet address under that incoming payment. This facilitates automation of processes like reconciliation of payment into the wallet address with external systems.  An outgoing payment is an instruction to make a payment out of the wallet address.  A quote is a commitment from the Account Servicing Entity to deliver a particular amount to a receiver when sending a particular amount from the wallet address. It is only valid for a limited time.  All resource and collection resource representations use JSON and the media-type `application/json`.    The `wallet address` resource has three collections of sub-resources: 1. `/incoming-payments` contains the **incoming payment** sub-resources   2. `/outgoing-payments` contains the **outgoing payment** sub-resources   3. `/quotes` contains the **quote** sub-resources  Access to resources and permission to execute the methods exposed by the API is determined by the grants given to the client represented by an access token used in API requests.
 *
 * The version of the OpenAPI document: 1.4
 * Contact: tech@interledger.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package io.fliqa.interledger.client;

import io.fliqa.interledger.ApiClient;
import io.fliqa.interledger.ApiException;
import io.fliqa.interledger.ApiResponse;
import io.fliqa.interledger.Pair;

import io.fliqa.interledger.client.model.CreateIncomingPaymentRequest;
import io.fliqa.interledger.client.model.GetIncomingPayment200Response;
import io.fliqa.interledger.client.model.IncomingPayment;
import io.fliqa.interledger.client.model.IncomingPaymentWithMethods;
import io.fliqa.interledger.client.model.ListIncomingPayments200Response;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.11.0")
public class IncomingPaymentApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public IncomingPaymentApi() {
    this(new ApiClient());
  }

  public IncomingPaymentApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Complete an Incoming Payment
   * A client with the appropriate permissions MAY mark a non-expired **incoming payment** as &#x60;completed&#x60; indicating that the client is not going to make any further payments toward this **incoming payment**, even though the full &#x60;incomingAmount&#x60; may not have been received.  This indicates to the receiving Account Servicing Entity that it can begin any post processing of the payment such as generating account statements or notifying the account holder of the completed payment.
   * @param signatureInput  (required)
   * @param signature The signature generated based on the Signature-Input, using the signing algorithm specified in the \&quot;alg\&quot; field of the JWK. (required)
   * @param id Sub-resource identifier (required)
   * @return IncomingPayment
   * @throws ApiException if fails to make API call
   */
  public IncomingPayment completeIncomingPayment(String signatureInput, String signature, String id) throws ApiException {
    ApiResponse<IncomingPayment> localVarResponse = completeIncomingPaymentWithHttpInfo(signatureInput, signature, id);
    return localVarResponse.getData();
  }

  /**
   * Complete an Incoming Payment
   * A client with the appropriate permissions MAY mark a non-expired **incoming payment** as &#x60;completed&#x60; indicating that the client is not going to make any further payments toward this **incoming payment**, even though the full &#x60;incomingAmount&#x60; may not have been received.  This indicates to the receiving Account Servicing Entity that it can begin any post processing of the payment such as generating account statements or notifying the account holder of the completed payment.
   * @param signatureInput  (required)
   * @param signature The signature generated based on the Signature-Input, using the signing algorithm specified in the \&quot;alg\&quot; field of the JWK. (required)
   * @param id Sub-resource identifier (required)
   * @return ApiResponse&lt;IncomingPayment&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<IncomingPayment> completeIncomingPaymentWithHttpInfo(String signatureInput, String signature, String id) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = completeIncomingPaymentRequestBuilder(signatureInput, signature, id);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("completeIncomingPayment", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<IncomingPayment>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<IncomingPayment>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<IncomingPayment>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder completeIncomingPaymentRequestBuilder(String signatureInput, String signature, String id) throws ApiException {
    // verify the required parameter 'signatureInput' is set
    if (signatureInput == null) {
      throw new ApiException(400, "Missing the required parameter 'signatureInput' when calling completeIncomingPayment");
    }
    // verify the required parameter 'signature' is set
    if (signature == null) {
      throw new ApiException(400, "Missing the required parameter 'signature' when calling completeIncomingPayment");
    }
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling completeIncomingPayment");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/incoming-payments/{id}/complete"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (signatureInput != null) {
      localVarRequestBuilder.header("Signature-Input", signatureInput.toString());
    }
    if (signature != null) {
      localVarRequestBuilder.header("Signature", signature.toString());
    }
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Create an Incoming Payment
   * A client MUST create an **incoming payment** resource before it is possible to send any payments to the wallet address.  When a client creates an **incoming payment** the receiving Account Servicing Entity generates unique payment details that can be used to address payments to the account and returns these details to the client as properties of the new **incoming payment**. Any payments received using those details are then associated with the **incoming payment**.  All of the input parameters are _optional_.  For example, the client could use the &#x60;metadata&#x60; property to store an external reference on the **incoming payment** and this can be shared with the account holder to assist with reconciliation.  If &#x60;incomingAmount&#x60; is specified and the total received using the payment details equals or exceeds the specified &#x60;incomingAmount&#x60;, then the receiving Account Servicing Entity MUST reject any further payments and set &#x60;completed&#x60; to &#x60;true&#x60;.  If an &#x60;expiresAt&#x60; value is defined, and the current date and time on the receiving Account Servicing Entity&#39;s systems exceeds that value, the receiving Account Servicing Entity MUST reject any further payments.
   * @param signatureInput  (required)
   * @param signature The signature generated based on the Signature-Input, using the signing algorithm specified in the \&quot;alg\&quot; field of the JWK. (required)
   * @param createIncomingPaymentRequest A subset of the incoming payments schema is accepted as input to create a new incoming payment.  The &#x60;incomingAmount&#x60; must use the same &#x60;assetCode&#x60; and &#x60;assetScale&#x60; as the wallet address. (required)
   * @return IncomingPaymentWithMethods
   * @throws ApiException if fails to make API call
   */
  public IncomingPaymentWithMethods createIncomingPayment(String signatureInput, String signature, CreateIncomingPaymentRequest createIncomingPaymentRequest) throws ApiException {
    ApiResponse<IncomingPaymentWithMethods> localVarResponse = createIncomingPaymentWithHttpInfo(signatureInput, signature, createIncomingPaymentRequest);
    return localVarResponse.getData();
  }

  /**
   * Create an Incoming Payment
   * A client MUST create an **incoming payment** resource before it is possible to send any payments to the wallet address.  When a client creates an **incoming payment** the receiving Account Servicing Entity generates unique payment details that can be used to address payments to the account and returns these details to the client as properties of the new **incoming payment**. Any payments received using those details are then associated with the **incoming payment**.  All of the input parameters are _optional_.  For example, the client could use the &#x60;metadata&#x60; property to store an external reference on the **incoming payment** and this can be shared with the account holder to assist with reconciliation.  If &#x60;incomingAmount&#x60; is specified and the total received using the payment details equals or exceeds the specified &#x60;incomingAmount&#x60;, then the receiving Account Servicing Entity MUST reject any further payments and set &#x60;completed&#x60; to &#x60;true&#x60;.  If an &#x60;expiresAt&#x60; value is defined, and the current date and time on the receiving Account Servicing Entity&#39;s systems exceeds that value, the receiving Account Servicing Entity MUST reject any further payments.
   * @param signatureInput  (required)
   * @param signature The signature generated based on the Signature-Input, using the signing algorithm specified in the \&quot;alg\&quot; field of the JWK. (required)
   * @param createIncomingPaymentRequest A subset of the incoming payments schema is accepted as input to create a new incoming payment.  The &#x60;incomingAmount&#x60; must use the same &#x60;assetCode&#x60; and &#x60;assetScale&#x60; as the wallet address. (required)
   * @return ApiResponse&lt;IncomingPaymentWithMethods&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<IncomingPaymentWithMethods> createIncomingPaymentWithHttpInfo(String signatureInput, String signature, CreateIncomingPaymentRequest createIncomingPaymentRequest) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = createIncomingPaymentRequestBuilder(signatureInput, signature, createIncomingPaymentRequest);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("createIncomingPayment", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<IncomingPaymentWithMethods>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<IncomingPaymentWithMethods>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<IncomingPaymentWithMethods>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder createIncomingPaymentRequestBuilder(String signatureInput, String signature, CreateIncomingPaymentRequest createIncomingPaymentRequest) throws ApiException {
    // verify the required parameter 'signatureInput' is set
    if (signatureInput == null) {
      throw new ApiException(400, "Missing the required parameter 'signatureInput' when calling createIncomingPayment");
    }
    // verify the required parameter 'signature' is set
    if (signature == null) {
      throw new ApiException(400, "Missing the required parameter 'signature' when calling createIncomingPayment");
    }
    // verify the required parameter 'createIncomingPaymentRequest' is set
    if (createIncomingPaymentRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'createIncomingPaymentRequest' when calling createIncomingPayment");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/incoming-payments";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (signatureInput != null) {
      localVarRequestBuilder.header("Signature-Input", signatureInput.toString());
    }
    if (signature != null) {
      localVarRequestBuilder.header("Signature", signature.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(createIncomingPaymentRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Get an Incoming Payment
   * A client can fetch the latest state of an incoming payment to determine the amount received into the wallet address.
   * @param id Sub-resource identifier (required)
   * @param signatureInput The Signature-Input field is a Dictionary structured field containing the metadata for one or more message signatures generated from components within the HTTP message.  Each member describes a single message signature.  The member&#39;s key is the label that uniquely identifies the message signature within the context of the HTTP message.  The member&#39;s value is the serialization of the covered components Inner List plus all signature metadata parameters identified by the label.  The following components MUST be included: - \&quot;@method\&quot; - \&quot;@target-uri\&quot; - \&quot;authorization\&quot;.  When the message contains a request body, the covered components MUST also include the following: - \&quot;content-digest\&quot;  The keyid parameter of the signature MUST be set to the kid value of the JWK.      See [ietf-httpbis-message-signatures](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-message-signatures#section-4.1) for more details. (optional)
   * @param signature The signature generated based on the Signature-Input, using the signing algorithm specified in the \&quot;alg\&quot; field of the JWK. (optional)
   * @return GetIncomingPayment200Response
   * @throws ApiException if fails to make API call
   */
  public GetIncomingPayment200Response getIncomingPayment(String id, String signatureInput, String signature) throws ApiException {
    ApiResponse<GetIncomingPayment200Response> localVarResponse = getIncomingPaymentWithHttpInfo(id, signatureInput, signature);
    return localVarResponse.getData();
  }

  /**
   * Get an Incoming Payment
   * A client can fetch the latest state of an incoming payment to determine the amount received into the wallet address.
   * @param id Sub-resource identifier (required)
   * @param signatureInput The Signature-Input field is a Dictionary structured field containing the metadata for one or more message signatures generated from components within the HTTP message.  Each member describes a single message signature.  The member&#39;s key is the label that uniquely identifies the message signature within the context of the HTTP message.  The member&#39;s value is the serialization of the covered components Inner List plus all signature metadata parameters identified by the label.  The following components MUST be included: - \&quot;@method\&quot; - \&quot;@target-uri\&quot; - \&quot;authorization\&quot;.  When the message contains a request body, the covered components MUST also include the following: - \&quot;content-digest\&quot;  The keyid parameter of the signature MUST be set to the kid value of the JWK.      See [ietf-httpbis-message-signatures](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-message-signatures#section-4.1) for more details. (optional)
   * @param signature The signature generated based on the Signature-Input, using the signing algorithm specified in the \&quot;alg\&quot; field of the JWK. (optional)
   * @return ApiResponse&lt;GetIncomingPayment200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetIncomingPayment200Response> getIncomingPaymentWithHttpInfo(String id, String signatureInput, String signature) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getIncomingPaymentRequestBuilder(id, signatureInput, signature);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getIncomingPayment", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<GetIncomingPayment200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<GetIncomingPayment200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetIncomingPayment200Response>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getIncomingPaymentRequestBuilder(String id, String signatureInput, String signature) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling getIncomingPayment");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/incoming-payments/{id}"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (signatureInput != null) {
      localVarRequestBuilder.header("Signature-Input", signatureInput.toString());
    }
    if (signature != null) {
      localVarRequestBuilder.header("Signature", signature.toString());
    }
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List Incoming Payments
   * List all incoming payments on the wallet address
   * @param walletAddress URL of a wallet address hosted by a Rafiki instance. (required)
   * @param signatureInput  (required)
   * @param signature The signature generated based on the Signature-Input, using the signing algorithm specified in the \&quot;alg\&quot; field of the JWK. (required)
   * @param cursor The cursor key to list from. (optional)
   * @param first The number of items to return after the cursor. (optional)
   * @param last The number of items to return before the cursor. (optional)
   * @return ListIncomingPayments200Response
   * @throws ApiException if fails to make API call
   */
  public ListIncomingPayments200Response listIncomingPayments(String walletAddress, String signatureInput, String signature, String cursor, Integer first, Integer last) throws ApiException {
    ApiResponse<ListIncomingPayments200Response> localVarResponse = listIncomingPaymentsWithHttpInfo(walletAddress, signatureInput, signature, cursor, first, last);
    return localVarResponse.getData();
  }

  /**
   * List Incoming Payments
   * List all incoming payments on the wallet address
   * @param walletAddress URL of a wallet address hosted by a Rafiki instance. (required)
   * @param signatureInput  (required)
   * @param signature The signature generated based on the Signature-Input, using the signing algorithm specified in the \&quot;alg\&quot; field of the JWK. (required)
   * @param cursor The cursor key to list from. (optional)
   * @param first The number of items to return after the cursor. (optional)
   * @param last The number of items to return before the cursor. (optional)
   * @return ApiResponse&lt;ListIncomingPayments200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListIncomingPayments200Response> listIncomingPaymentsWithHttpInfo(String walletAddress, String signatureInput, String signature, String cursor, Integer first, Integer last) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = listIncomingPaymentsRequestBuilder(walletAddress, signatureInput, signature, cursor, first, last);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("listIncomingPayments", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<ListIncomingPayments200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<ListIncomingPayments200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ListIncomingPayments200Response>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder listIncomingPaymentsRequestBuilder(String walletAddress, String signatureInput, String signature, String cursor, Integer first, Integer last) throws ApiException {
    // verify the required parameter 'walletAddress' is set
    if (walletAddress == null) {
      throw new ApiException(400, "Missing the required parameter 'walletAddress' when calling listIncomingPayments");
    }
    // verify the required parameter 'signatureInput' is set
    if (signatureInput == null) {
      throw new ApiException(400, "Missing the required parameter 'signatureInput' when calling listIncomingPayments");
    }
    // verify the required parameter 'signature' is set
    if (signature == null) {
      throw new ApiException(400, "Missing the required parameter 'signature' when calling listIncomingPayments");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/incoming-payments";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "wallet-address";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("wallet-address", walletAddress));
    localVarQueryParameterBaseName = "cursor";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("cursor", cursor));
    localVarQueryParameterBaseName = "first";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("first", first));
    localVarQueryParameterBaseName = "last";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("last", last));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    if (signatureInput != null) {
      localVarRequestBuilder.header("Signature-Input", signatureInput.toString());
    }
    if (signature != null) {
      localVarRequestBuilder.header("Signature", signature.toString());
    }
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

}
